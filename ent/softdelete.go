// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"time"

	"entgo.io/bug/ent/group"
	"entgo.io/bug/ent/todo"
	"entgo.io/bug/ent/user"
	"entgo.io/ent"
	"entgo.io/ent/entql"
)

func FilterDeleted(q Query) {
	switch v := q.(type) {
	case *GroupQuery:
		v.Filter().WhereDeletedTime(entql.TimeNil())
		if v.withUsers != nil {
			FilterDeleted(v.withUsers)
		}
	case *TodoQuery:
		v.Filter().WhereDeletedTime(entql.TimeNil())
		if v.withCreator != nil {
			FilterDeleted(v.withCreator)
		}
	case *UserQuery:
		v.Filter().WhereDeletedTime(entql.TimeNil())
		if v.withGroups != nil {
			FilterDeleted(v.withGroups)
		}
		if v.withTodos != nil {
			FilterDeleted(v.withTodos)
		}
	}
}

func MarkAsDeleted(ctx context.Context, m ent.Mutation, t time.Time) (ent.Value, error) {
	if p, ok := m.(interface {
		IDs(ctx context.Context) ([]int, error)
		Client() *Client
	}); ok {
		ids, err := p.IDs(ctx)
		if err != nil {
			return nil, err
		}
		switch m.Type() {
		case "Group":
			if err := p.Client().Group.Update().Where(group.IDIn(ids...)).SetDeletedTime(t).Exec(ctx); err != nil {
				return nil, err
			}
		case "Todo":
			if err := p.Client().Todo.Update().Where(todo.IDIn(ids...)).SetDeletedTime(t).Exec(ctx); err != nil {
				return nil, err
			}
		case "User":
			if err := p.Client().User.Update().Where(user.IDIn(ids...)).SetDeletedTime(t).Exec(ctx); err != nil {
				return nil, err
			}
		default:
			return nil, fmt.Errorf("invalid case, %q is not using softdelete", m.Type())
		}
		return len(ids), nil
	}
	return nil, fmt.Errorf("invalid type assertion")
}
