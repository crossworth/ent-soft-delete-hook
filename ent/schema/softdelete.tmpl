{{ define "softdelete" }}

    {{ $pkg := base $.Config.Package }}
    {{ template "header" $ }}

    import (
        "entgo.io/ent"
    )

    func FilterDeleted(q Query) {
        switch v := q.(type) {
        {{- range $n := $.Nodes }}
            {{- if $n.Annotations.DeletedTime.OK -}}
        case *{{ $n.Name }}Query:
            v.Filter().WhereDeletedTime(entql.TimeNil())
            {{- range $e := $n.Edges }}
                if v.with{{ $e.Name | pascal }} != nil {
                    FilterDeleted(v.with{{ $e.Name | pascal }})
                }
            {{- end }}
            {{ end -}}
        {{- end -}}
        }
    }

    func MarkAsDeleted(ctx context.Context, m ent.Mutation, t time.Time) (ent.Value, error) {
        if p, ok := m.(interface {
            IDs(ctx context.Context) ([]int, error)
            Client() *Client
        }); ok {
            ids, err := p.IDs(ctx)
            if err != nil {
                return nil, err
            }
            switch m.Type() {
            {{- range $n := $.Nodes }}
                {{- if $n.Annotations.DeletedTime.OK -}}
            case "{{ $n.Name }}":
                if err := p.Client().{{ $n.Name }}.Update().Where({{ $n.Name | lower }}.IDIn(ids...)).SetDeletedTime(t).Exec(ctx); err != nil {
                    return nil, err
                }
                {{ end }}
            {{- end -}}
            default:
                return nil, fmt.Errorf("invalid case, %q is not using softdelete", m.Type())
            }
            return len(ids), nil
        }
        return nil, fmt.Errorf("invalid type assertion")
    }

{{ end }}